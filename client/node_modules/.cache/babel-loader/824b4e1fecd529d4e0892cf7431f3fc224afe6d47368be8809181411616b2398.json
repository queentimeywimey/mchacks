{"ast":null,"code":"var _jsxFileName = \"/Users/denalitran-le/Documents/GitHub/mchacks/client/src/contexts/SocketContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState } from 'react';\nimport { io } from 'socket.io-client';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SocketContext = /*#__PURE__*/createContext(null);\nexport const SocketProvider = ({\n  children\n}) => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isProvider, setIsProvider] = useState(false);\n  const [patients, setPatients] = useState([]);\n  useEffect(() => {\n    const newSocket = io('http://localhost:3001');\n    newSocket.on('connect', () => {\n      setIsConnected(true);\n      console.log('Connected to server');\n    });\n    newSocket.on('disconnect', () => {\n      setIsConnected(false);\n      console.log('Disconnected from server');\n    });\n    newSocket.on('patients-updated', updatedPatients => {\n      setPatients(updatedPatients);\n    });\n    setSocket(newSocket);\n    return () => {\n      newSocket.close();\n    };\n  }, []);\n  const authenticateProvider = async password => {\n    if (!socket) return false;\n    return new Promise(resolve => {\n      socket.emit('provider-auth', password, response => {\n        setIsProvider(response.success);\n        resolve(response.success);\n      });\n    });\n  };\n  const addPatient = async (name, symptoms, triageLevel) => {\n    if (!socket) throw new Error('Not connected');\n    return new Promise(resolve => {\n      socket.emit('add-patient', {\n        name,\n        symptoms,\n        triageLevel\n      }, response => {\n        if (response.success) {\n          resolve(response.patientId);\n        }\n      });\n    });\n  };\n  const updateSymptoms = update => {\n    if (!socket) return;\n    socket.emit('update-symptoms', update);\n  };\n  const removePatient = patientId => {\n    if (!socket) return;\n    socket.emit('remove-patient', patientId);\n  };\n  const getPatient = async patientId => {\n    if (!socket) return null;\n    return new Promise(resolve => {\n      socket.emit('get-patient', patientId, patient => {\n        resolve(patient);\n      });\n    });\n  };\n  const updateTriageLevel = (patientId, triageLevel) => {\n    if (!socket) return;\n    socket.emit('update-triage-level', {\n      patientId,\n      triageLevel\n    });\n  };\n  const value = {\n    socket,\n    isConnected,\n    isProvider,\n    setIsProvider,\n    authenticateProvider,\n    addPatient,\n    updateSymptoms,\n    updateTriageLevel,\n    removePatient,\n    getPatient,\n    patients\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 122,\n    columnNumber: 9\n  }, this);\n};\n_s(SocketProvider, \"iDvCk0JQinps0gY8pDWjMSlNEf8=\");\n_c = SocketProvider;\nexport const useSocket = () => {\n  _s2();\n  const context = useContext(SocketContext);\n  if (!context) {\n    throw new Error('useSocket must be used within a SocketProvider');\n  }\n  return context;\n};\n_s2(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","io","jsxDEV","_jsxDEV","SocketContext","SocketProvider","children","_s","socket","setSocket","isConnected","setIsConnected","isProvider","setIsProvider","patients","setPatients","newSocket","on","console","log","updatedPatients","close","authenticateProvider","password","Promise","resolve","emit","response","success","addPatient","name","symptoms","triageLevel","Error","patientId","updateSymptoms","update","removePatient","getPatient","patient","updateTriageLevel","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useSocket","_s2","context","$RefreshReg$"],"sources":["/Users/denalitran-le/Documents/GitHub/mchacks/client/src/contexts/SocketContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState } from 'react';\nimport { io, Socket } from 'socket.io-client';\nimport { Patient, PatientUpdate } from '../types';\n\ninterface SocketContextType {\n    socket: Socket | null;\n    isConnected: boolean;\n    isProvider: boolean;\n    setIsProvider: (value: boolean) => void;\n    authenticateProvider: (password: string) => Promise<boolean>;\n    addPatient: (name: string, symptoms: string[], triageLevel: 1 | 2 | 3 | 4 | 5) => Promise<string>;\n    updateSymptoms: (update: PatientUpdate) => void;\n    updateTriageLevel: (patientId: string, triageLevel: 1 | 2 | 3 | 4 | 5) => void;\n    removePatient: (patientId: string) => void;\n    getPatient: (patientId: string) => Promise<Patient | null>;\n    patients: Patient[];\n}\n\nconst SocketContext = createContext<SocketContextType | null>(null);\n\nexport const SocketProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    const [socket, setSocket] = useState<Socket | null>(null);\n    const [isConnected, setIsConnected] = useState(false);\n    const [isProvider, setIsProvider] = useState(false);\n    const [patients, setPatients] = useState<Patient[]>([]);\n\n    useEffect(() => {\n        const newSocket = io('http://localhost:3001');\n\n        newSocket.on('connect', () => {\n            setIsConnected(true);\n            console.log('Connected to server');\n        });\n\n        newSocket.on('disconnect', () => {\n            setIsConnected(false);\n            console.log('Disconnected from server');\n        });\n\n        newSocket.on('patients-updated', (updatedPatients: Patient[]) => {\n            setPatients(updatedPatients);\n        });\n\n        setSocket(newSocket);\n\n        return () => {\n            newSocket.close();\n        };\n    }, []);\n\n    const authenticateProvider = async (password: string): Promise<boolean> => {\n        if (!socket) return false;\n        \n        return new Promise((resolve) => {\n            socket.emit('provider-auth', password, (response: { success: boolean }) => {\n                setIsProvider(response.success);\n                resolve(response.success);\n            });\n        });\n    };\n\n    const addPatient = async (\n        name: string,\n        symptoms: string[],\n        triageLevel: 1 | 2 | 3 | 4 | 5\n    ): Promise<string> => {\n        if (!socket) throw new Error('Not connected');\n\n        return new Promise((resolve) => {\n            socket.emit(\n                'add-patient',\n                { name, symptoms, triageLevel },\n                (response: { success: boolean; patientId: string }) => {\n                    if (response.success) {\n                        resolve(response.patientId);\n                    }\n                }\n            );\n        });\n    };\n\n    const updateSymptoms = (update: PatientUpdate) => {\n        if (!socket) return;\n        socket.emit('update-symptoms', update);\n    };\n\n    const removePatient = (patientId: string) => {\n        if (!socket) return;\n        socket.emit('remove-patient', patientId);\n    };\n\n    const getPatient = async (patientId: string): Promise<Patient | null> => {\n        if (!socket) return null;\n\n        return new Promise((resolve) => {\n            socket.emit('get-patient', patientId, (patient: Patient | null) => {\n                resolve(patient);\n            });\n        });\n    };\n\n    const updateTriageLevel = (patientId: string, triageLevel: 1 | 2 | 3 | 4 | 5) => {\n        if (!socket) return;\n        socket.emit('update-triage-level', { patientId, triageLevel });\n    };\n\n    const value = {\n        socket,\n        isConnected,\n        isProvider,\n        setIsProvider,\n        authenticateProvider,\n        addPatient,\n        updateSymptoms,\n        updateTriageLevel,\n        removePatient,\n        getPatient,\n        patients\n    };\n\n    return (\n        <SocketContext.Provider value={value}>\n            {children}\n        </SocketContext.Provider>\n    );\n};\n\nexport const useSocket = () => {\n    const context = useContext(SocketContext);\n    if (!context) {\n        throw new Error('useSocket must be used within a SocketProvider');\n    }\n    return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}